// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Template xpt/WSDL-File-Async-Callback.xpt 1`] = `
{
  "ejs": "<%#
Generates the Async Response .wsdl-Files for a synchronous WSDLPortType
=> async (Consumer) / sync (Provider) mapping
%>

// Import: com::tmobile::ei::sbp::mm::content::core::iface

<% include('extensions::osb') %>
<%#
Assumptions:
- default-namespace in wsdl:definitions is always "http://schemas.xmlsoap.org/wsdl/"
  AND IGNORED by Importer (so we include default-namespace hardcoded here)
- prefixes "wsdl" and "soap"
  AND IGNORED by Importer (so we include them hardcoded here)
%>
<%# TODO: DEFINE Method "WSDLPortType" on type "Root(String baseDir, String relDir, boolean abstract, boolean inline, boolean oneWay)" %><% { %>}
	<%# TODO: File Handling
    write file 'baseDir + (relDir != null ? '/' + relDir.ensureEndsWithSlash() : '/') + WsdlFile("_Callback")'
    %>'<?xml version="1.0" encoding="UTF-8"?>
<wsdl:definitions
		name="<%-NameX()%>Definitions"
		targetNamespace="<%-TargetNamespaceUri()%>"
		xmlns:tns="<%-TargetNamespaceUri()%>"
		xmlns="http://schemas.xmlsoap.org/wsdl/"
		xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
		xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
	>
	<!-- CEISeR version of WSDLPortType: <%-validFromVersion%> (Branch: <%-connectionToken.branch%>) -->
	<!-- version: <%-Version()%> -->
	<%if (targetNamespace.description != null) {%>
	<wsdl:documentation><%-escapeXml(targetNamespace.description)%></wsdl:documentation>
	<% } /* end-if */ %>
	<wsdl:types>
	<%if (inline) {%>
		<% RecursiveReferencedNamespaceNotWellKnownOrOwn().forEach(currentNamespace => { %>
			<%- include('XmlSchema::Root', { args: [this, relDir != null ? relDir.ensureEndsWithSlash() + Directory() : Directory(), inline] }') %>
		</xsd:schema>
		<% } /* end-forEach */ %>
	<% } /* end-if */ %>
		<%- include('XmlSchema::Root', { args: [this, relDir != null ? relDir.ensureEndsWithSlash() + Directory() : Directory(), inline] }') %>
			<% { const eiPrefix  = UsedPrefixes(targetNamespace).selectFirst(e|e.serviceNamespace.URI == getFoundationNamespaceURI()) %>
			<% operations.reject(e|e.isCheckAlive()).forEach(operation  => { %>
			<xsd:element name="<%-ResponseElementName(operation)%>Acknowledge" type="<%-eiPrefix.NameX()%>:acknowledgeRespType"/>
			<%# empty response "ack" for incoming Fault message %>
			<xsd:element name="<%-operation.NameX()%><%-getPostFixAsyncFaultOperation()%>" type="<%-eiPrefix.NameX()%>:mepMappingFaultToBodyType"/>
			<% } /* end-forEach */ %>
			<% } /* end-let */ %>
		</xsd:schema>
	</wsdl:types>
	<!-- ****************************************************************** -->
	<% operations.forEach(operation  => { %>
	<%if (operation.isCheckAlive()) {%>
	<% operation.UsedMessages().forEach(message => { %>
	<wsdl:message name="<%-message.NameX()%>">
		<%if (message.description != null) {%>
		<wsdl:documentation><%-escapeXml(description)%></wsdl:documentation>
		<% } /* end-if */ %>
		<% message.parts.forEach(part => { %>
		<wsdl:part name="<%-part.NameX()%>" element="tns:<%-part.messageType.NameX()%>" />
		<% } /* end-forEach */ %>
	</wsdl:message>
	<% } /* end-forEach */ %>
	<% } else { %>
	<% { const message = operation.output.message %>
	<wsdl:message name="<%-message.NameX()%>">
		<%if (message.description != null) {%>
		<wsdl:documentation><%-escapeXml(description)%></wsdl:documentation>
		<% } /* end-if */ %>
		<% (Collection[WSDLMessagePart])message.parts.forEach(part  => { %>
		<wsdl:part name="<%-part.NameX()%>" element="tns:<%-part.messageType.NameX()%>" />
		<% } /* end-forEach */ %>
	</wsdl:message>
	<wsdl:message name="<%-operation.NameX()%><%-getPostFixAsyncFaultOperation()%>">
		<wsdl:part name="parameters" element="tns:<%-operation.NameX()%><%-getPostFixAsyncFaultOperation()%>" />
	</wsdl:message>
	<wsdl:message name="<%-message.NameX()%>_Output">
		<wsdl:part name="parameters" element="tns:<%-ResponseElementName(operation)%>Acknowledge" />
	</wsdl:message>
	<wsdl:message name="<%-message.NameX()%>_Fault">
		<wsdl:part name="fault" element="tns:FaultDetail" />
	</wsdl:message>
	<% } /* end-let */ %>
	<% } /* end-if */ %>
	<% } /* end-forEach */ %>
	<!-- ****************************************************************** -->
	<wsdl:portType name="<%-WsdlPortTypeName()%>Callback">
		<%if (description != null) {%>
		<wsdl:documentation><%-escapeXml(description)%></wsdl:documentation>
		<% } /* end-if */ %>
		<% operations.reject(e|e.isCheckAlive()).forEach(operation  => { %>
		<wsdl:operation name="<%-ResponseElementName(operation)%>">
			<%if (operation.description != null) {%>
			<wsdl:documentation><%-escapeXml(operation.description)%></wsdl:documentation>
			<% } /* end-if */ %>
			<wsdl:input<%if (!operation.isInputLogicallyNameless()) {%> name="<%-operation.output.NameX()%>"<% } /* end-if */ %> message="tns:<%-operation.output.message.NameX()%>" />
			<%if (!oneWay) {%>
			<wsdl:output message="tns:<%-operation.output.message.NameX()%>_Output" />
			<wsdl:fault message="tns:<%-operation.output.message.NameX()%>_Fault" name="TechnicalExceptionFault" />
			<% } /* end-if */ %>
		</wsdl:operation>
		<wsdl:operation name="<%-operation.NameX()%><%-getPostFixAsyncFaultOperation()%>">
			<%if (operation.description != null) {%>
			<wsdl:documentation><%-escapeXml(operation.description)%></wsdl:documentation>
			<% } /* end-if */ %>
			<wsdl:input message="tns:<%-operation.NameX()%><%-getPostFixAsyncFaultOperation()%>" />
			<%if (!oneWay) {%>
			<wsdl:output message="tns:<%-operation.output.message.NameX()%>_Output" />
			<wsdl:fault message="tns:<%-operation.output.message.NameX()%>_Fault" name="TechnicalExceptionFault" />
			<% } /* end-if */ %>
		</wsdl:operation>
		<% } /* end-forEach */ %>
		<% { const operation = operations.selectFirst(e|e.isCheckAlive()) %>
		<%if (operation != null) {%>
		<wsdl:operation name="<%-operation.NameX()%>">
			<%- include('WsdlFile::AbstractOperationContent', { args: [oneWay] }') %>
		</wsdl:operation>
		<% } /* end-if */ %>
		<% } /* end-let */ %>
	</wsdl:portType>
	<%if (!abstract ) {%>
	<!-- ****************************************************************** -->
	<wsdl:binding name="<%-WsdlPortTypeName()%>CallbackBinding" type="tns:<%-WsdlPortTypeName()%>Callback">
		<soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http" />
		<% operations.reject(e|e.isCheckAlive()).forEach(operation  => { %>
		<wsdl:operation name="<%-ResponseElementName(operation)%>">
			<soap:operation soapAction=""/>
			<wsdl:input>
				<soap:body use="literal" />
			</wsdl:input>
			<%if (!oneWay) {%>
			<wsdl:output>
				<soap:body use="literal" />
			</wsdl:output>
			<wsdl:fault name="TechnicalExceptionFault">
				<soap:fault name="TechnicalExceptionFault" use="literal" />
			</wsdl:fault>
			<% } /* end-if */ %>
		</wsdl:operation>
		<wsdl:operation name="<%-operation.NameX()%><%-getPostFixAsyncFaultOperation()%>">
			<soap:operation soapAction=""/>
			<wsdl:input>
				<soap:body use="literal" />
			</wsdl:input>
			<%if (!oneWay) {%>
			<wsdl:output>
				<soap:body use="literal" />
			</wsdl:output>
			<wsdl:fault name="TechnicalExceptionFault">
				<soap:fault name="TechnicalExceptionFault" use="literal" />
			</wsdl:fault>
			<% } /* end-if */ %>
		</wsdl:operation>
		<% } /* end-forEach */ %>
		<% { const operation = operations.selectFirst(e|e.isCheckAlive()) %>
		<%if (operation != null) {%>
		<wsdl:operation name="<%-operation.NameX()%>">
			<soap:operation<%if (operation.soapAction != null) {%> soapAction="<%-operation.soapAction%>"<% } else { %> soapAction=""<% } /* end-if */ %>/>
			<%- include('WsdlFile::BindingOperationContent', { args: [oneWay] }') %>
		</wsdl:operation>
		<% } /* end-if */ %>
		<% } /* end-let */ %>
	</wsdl:binding>
	<!-- ****************************************************************** -->
	<wsdl:service name="<%-WsdlPortTypeName()%>CallbackService">
		<wsdl:port name="<%-WsdlPortTypeName()%>Callback" binding="tns:<%-WsdlPortTypeName()%>CallbackBinding">
			<soap:address location="<%-DummyServicePortAddressLocationPrefix()%>" />
		</wsdl:port>
	</wsdl:service>
	<% } /* end-if */ %>
</wsdl:definitions>
	<%-ENDFILE%>
<% } /* end-define */ %>
",
  "error": [],
  "instructions": [
    "[IMPORT] 'com::tmobile::ei::sbp::mm::content::core::iface' - check adaptation",
    "[EXTENSION] Included script 'extensions::osb' - check existence and name",
    "[DEFINE] Handle method definition: Root(String baseDir, String relDir, boolean abstract, boolean inline, boolean oneWay) FOR WSDLPortType",
    "[FILE] Handle creation of file 'baseDir + (relDir != null ? '/' + relDir.ensureEndsWithSlash() : '/') + WsdlFile("_Callback")'",
    "[SUBSTITUTION] Check "NameX()"",
    "[SUBSTITUTION] Check "TargetNamespaceUri()"",
    "[SUBSTITUTION] Check "TargetNamespaceUri()"",
    "[SUBSTITUTION] Check "validFromVersion"",
    "[SUBSTITUTION] Check "connectionToken.branch"",
    "[SUBSTITUTION] Check "Version()"",
    "Resolve "targetNamespace.description != null"",
    "[SUBSTITUTION] Check "escapeXml(targetNamespace.description)"",
    "Resolve "inline"",
    "[FOREACH] Handle foreach definition: RecursiveReferencedNamespaceNotWellKnownOrOwn() AS currentNamespace",
    "[EXPAND] Included template 'XmlSchema::Root(this, relDir != null ? relDir.ensureEndsWithSlash() + Directory() : Directory(), inline) FOR currentNamespace' - check resolution and skipped tail: ") FOR currentNamespace"",
    "[EXPAND] Included template 'XmlSchema::Root(this, relDir != null ? relDir.ensureEndsWithSlash() + Directory() : Directory(), inline) FOR targetNamespace' - check resolution and skipped tail: ") FOR targetNamespace"",
    "[LET] Handle variable definition: UsedPrefixes(targetNamespace).selectFirst(e|e.serviceNamespace.URI == getFoundationNamespaceURI()) AS eiPrefix ",
    "[FOREACH] Handle foreach definition: operations.reject(e|e.isCheckAlive()) AS operation ",
    "[SUBSTITUTION] Check "ResponseElementName(operation)"",
    "[SUBSTITUTION] Check "eiPrefix.NameX()"",
    "[SUBSTITUTION] Check "operation.NameX()"",
    "[SUBSTITUTION] Check "getPostFixAsyncFaultOperation()"",
    "[SUBSTITUTION] Check "eiPrefix.NameX()"",
    "[FOREACH] Handle foreach definition: operations AS operation ",
    "Resolve "operation.isCheckAlive()"",
    "[FOREACH] Handle foreach definition: operation.UsedMessages() AS message",
    "[SUBSTITUTION] Check "message.NameX()"",
    "Resolve "message.description != null"",
    "[SUBSTITUTION] Check "escapeXml(description)"",
    "[FOREACH] Handle foreach definition: message.parts AS part",
    "[SUBSTITUTION] Check "part.NameX()"",
    "[SUBSTITUTION] Check "part.messageType.NameX()"",
    "[LET] Handle variable definition: operation.output.message AS message",
    "[SUBSTITUTION] Check "message.NameX()"",
    "Resolve "message.description != null"",
    "[SUBSTITUTION] Check "escapeXml(description)"",
    "[FOREACH] Handle foreach definition: (Collection[WSDLMessagePart])message.parts AS part ",
    "[SUBSTITUTION] Check "part.NameX()"",
    "[SUBSTITUTION] Check "part.messageType.NameX()"",
    "[SUBSTITUTION] Check "operation.NameX()"",
    "[SUBSTITUTION] Check "getPostFixAsyncFaultOperation()"",
    "[SUBSTITUTION] Check "operation.NameX()"",
    "[SUBSTITUTION] Check "getPostFixAsyncFaultOperation()"",
    "[SUBSTITUTION] Check "message.NameX()"",
    "[SUBSTITUTION] Check "ResponseElementName(operation)"",
    "[SUBSTITUTION] Check "message.NameX()"",
    "[SUBSTITUTION] Check "WsdlPortTypeName()"",
    "Resolve "description != null"",
    "[SUBSTITUTION] Check "escapeXml(description)"",
    "[FOREACH] Handle foreach definition: operations.reject(e|e.isCheckAlive()) AS operation ",
    "[SUBSTITUTION] Check "ResponseElementName(operation)"",
    "Resolve "operation.description != null"",
    "[SUBSTITUTION] Check "escapeXml(operation.description)"",
    "Resolve "!operation.isInputLogicallyNameless()"",
    "[SUBSTITUTION] Check "operation.output.NameX()"",
    "[SUBSTITUTION] Check "operation.output.message.NameX()"",
    "Resolve "!oneWay"",
    "[SUBSTITUTION] Check "operation.output.message.NameX()"",
    "[SUBSTITUTION] Check "operation.output.message.NameX()"",
    "[SUBSTITUTION] Check "operation.NameX()"",
    "[SUBSTITUTION] Check "getPostFixAsyncFaultOperation()"",
    "Resolve "operation.description != null"",
    "[SUBSTITUTION] Check "escapeXml(operation.description)"",
    "[SUBSTITUTION] Check "operation.NameX()"",
    "[SUBSTITUTION] Check "getPostFixAsyncFaultOperation()"",
    "Resolve "!oneWay"",
    "[SUBSTITUTION] Check "operation.output.message.NameX()"",
    "[SUBSTITUTION] Check "operation.output.message.NameX()"",
    "[LET] Handle variable definition: operations.selectFirst(e|e.isCheckAlive()) AS operation",
    "Resolve "operation != null"",
    "[SUBSTITUTION] Check "operation.NameX()"",
    "[EXPAND] Included template 'WsdlFile::AbstractOperationContent(oneWay) FOR operation' - check resolution and skipped tail: ") FOR operation"",
    "Resolve "!abstract "",
    "[SUBSTITUTION] Check "WsdlPortTypeName()"",
    "[SUBSTITUTION] Check "WsdlPortTypeName()"",
    "[FOREACH] Handle foreach definition: operations.reject(e|e.isCheckAlive()) AS operation ",
    "[SUBSTITUTION] Check "ResponseElementName(operation)"",
    "Resolve "!oneWay"",
    "[SUBSTITUTION] Check "operation.NameX()"",
    "[SUBSTITUTION] Check "getPostFixAsyncFaultOperation()"",
    "Resolve "!oneWay"",
    "[LET] Handle variable definition: operations.selectFirst(e|e.isCheckAlive()) AS operation",
    "Resolve "operation != null"",
    "[SUBSTITUTION] Check "operation.NameX()"",
    "Resolve "operation.soapAction != null"",
    "[SUBSTITUTION] Check "operation.soapAction"",
    "[EXPAND] Included template 'WsdlFile::BindingOperationContent(oneWay) FOR operation' - check resolution and skipped tail: ") FOR operation"",
    "[SUBSTITUTION] Check "WsdlPortTypeName()"",
    "[SUBSTITUTION] Check "WsdlPortTypeName()"",
    "[SUBSTITUTION] Check "WsdlPortTypeName()"",
    "[SUBSTITUTION] Check "DummyServicePortAddressLocationPrefix()"",
    "[SUBSTITUTION] Check "ENDFILE"",
  ],
}
`;
